{"version":3,"file":"polygon-clipping.umd.min.js","sources":["../node_modules/splaytree/index.js","../src/flp.js","../src/vector.js","../src/clean-input.js","../src/sweep-event.js","../src/segment.js","../src/bbox.js","../src/geom-in.js","../src/geom-out.js","../src/sweep-line.js","../src/operation.js","../src/index.js"],"sourcesContent":["/* follows \"An implementation of top-down splaying\"\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\n */\n\n/**\n * @typedef {*} Key\n */\n\n\n/**\n * @typedef {*} Value\n */\n\n\n/**\n * @typedef {function(node:Node):void} Visitor\n */\n\n\n/**\n * @typedef {function(a:Key, b:Key):number} Comparator\n */\n\n\n/**\n * @param {function(node:Node):string} NodePrinter\n */\n\n\n/**\n * @typedef {Object}  Node\n * @property {Key}    Key\n * @property {Value=} data\n * @property {Node}   left\n * @property {Node}   right\n */\n\nclass Node {\n\n  constructor (key, data) {\n    this.key    = key;\n    this.data   = data;\n    this.left   = null;\n    this.right  = null;\n  }\n}\n\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Simple top down splay, not requiring i to be in the tree t.\n * @param {Key} i\n * @param {Node?} t\n * @param {Comparator} comparator\n */\nfunction splay (i, t, comparator) {\n  if (t === null) return t;\n  let l, r, y;\n  const N = new Node();\n  l = r = N;\n\n  while (true) {\n    const cmp = comparator(i, t.key);\n    //if (i < t.key) {\n    if (cmp < 0) {\n      if (t.left === null) break;\n      //if (i < t.left.key) {\n      if (comparator(i, t.left.key) < 0) {\n        y = t.left;                           /* rotate right */\n        t.left = y.right;\n        y.right = t;\n        t = y;\n        if (t.left === null) break;\n      }\n      r.left = t;                               /* link right */\n      r = t;\n      t = t.left;\n    //} else if (i > t.key) {\n    } else if (cmp > 0) {\n      if (t.right === null) break;\n      //if (i > t.right.key) {\n      if (comparator(i, t.right.key) > 0) {\n        y = t.right;                          /* rotate left */\n        t.right = y.left;\n        y.left = t;\n        t = y;\n        if (t.right === null) break;\n      }\n      l.right = t;                              /* link left */\n      l = t;\n      t = t.right;\n    } else {\n      break;\n    }\n  }\n  /* assemble */\n  l.right = t.left;\n  r.left = t.right;\n  t.left = N.right;\n  t.right = N.left;\n  return t;\n}\n\n\n/**\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}      root\n */\nfunction insert (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  tree._size++;\n\n  if (t === null) {\n    node.left = node.right = null;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp < 0) {\n    node.left = t.left;\n    node.right = t;\n    t.left = null;\n  } else if (cmp >= 0) {\n    node.right = t.right;\n    node.left = t;\n    t.right = null;\n  }\n  return node;\n}\n\n\n/**\n * Insert i into the tree t, unless it's already there.\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}       root\n */\nfunction add (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  if (t === null) {\n    node.left = node.right = null;\n    tree._size++;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp === 0) return t;\n  else {\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp > 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    tree._size++;\n    return node;\n  }\n}\n\n\n/**\n * Deletes i from the tree if it's there\n * @param {Key}        i\n * @param {Tree}       tree\n * @param {Comparator} comparator\n * @param {Tree}       tree\n * @return {Node}      new root\n */\nfunction remove (i, t, comparator, tree) {\n  let x;\n  if (t === null) return null;\n  t = splay(i, t, comparator);\n  var cmp = comparator(i, t.key);\n  if (cmp === 0) {               /* found it */\n    if (t.left === null) {\n      x = t.right;\n    } else {\n      x = splay(i, t.left, comparator);\n      x.right = t.right;\n    }\n    tree._size--;\n    return x;\n  }\n  return t;                         /* It wasn't there */\n}\n\n\nfunction split (key, v, comparator) {\n  let left, right;\n  if (v === null) {\n    left = right = null;\n  } else {\n    v = splay(key, v, comparator);\n\n    const cmp = comparator(v.key, key);\n    if (cmp === 0) {\n      left  = v.left;\n      right = v.right;\n    } else if (cmp < 0) {\n      right   = v.right;\n      v.right = null;\n      left    = v;\n    } else {\n      left   = v.left;\n      v.left = null;\n      right  = v;\n    }\n  }\n  return { left, right };\n}\n\n\nfunction merge (left, right, comparator) {\n  if (right === null) return left;\n  if (left  === null) return right;\n\n  right = splay(left.key, right, comparator);\n  right.left = left;\n  return right;\n}\n\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Array<string>}               out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction printRow (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  printRow(root.left,  indent, false, out, printNode);\n    if (root.right) printRow(root.right, indent, true,  out, printNode);\n  }\n}\n\n\nexport default class Tree {\n\n  constructor (comparator = DEFAULT_COMPARE) {\n    this._comparator = comparator;\n    this._root = null;\n    this._size = 0;\n  }\n\n\n  /**\n   * Inserts a key, allows duplicates\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  insert (key, data) {\n    return this._root = insert(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Adds a key, if it is not present in the tree\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  add (key, data) {\n    return this._root = add(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  remove (key) {\n    this._root = remove(key, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    let node = this._root;\n    if (node) {\n      while (node.left) node = node.left;\n      this._root = splay(node.key,  this._root, this._comparator);\n      this._root = remove(node.key, this._root, this._comparator, this);\n      return { key: node.key, data: node.data };\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  findStatic (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return current;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  find (key) {\n    if (this._root) {\n      this._root = splay(key, this._root, this._comparator);\n      if (this._comparator(key, this._root.key) !== 0) return null;\n    }\n    return this._root;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Boolean}\n   */\n  contains (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return true;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return false;\n  }\n\n\n  /**\n   * @param  {Visitor} visitor\n   * @param  {*=}      ctx\n   * @return {SplayTree}\n   */\n  forEach (visitor, ctx) {\n    let current = this._root;\n    const Q = [];  /* Initialize stack s */\n    let done = false;\n\n    while (!done) {\n      if (current !==  null) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length !== 0) {\n          current = Q.pop();\n          visitor.call(ctx, current);\n\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range (low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Returns array of keys\n   * @return {Array<Key>}\n   */\n  keys () {\n    const keys = [];\n    this.forEach(({ key }) => keys.push(key));\n    return keys;\n  }\n\n\n  /**\n   * Returns array of all the data in the nodes\n   * @return {Array<Value>}\n   */\n  values () {\n    const values = [];\n    this.forEach(({ data }) => values.push(data));\n    return values;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  min() {\n    if (this._root) return this.minNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  max() {\n    if (this._root) return this.maxNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  minNode(t = this._root) {\n    if (t) while (t.left) t = t.left;\n    return t;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  maxNode(t = this._root) {\n    if (t) while (t.right) t = t.right;\n    return t;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    let current = this._root, done = false, i = 0;\n    const Q = [];\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = Q.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Node}   d\n   * @return {Node|null}\n   */\n  next (d) {\n    let root = this._root;\n    let successor = null;\n\n    if (d.right) {\n      successor = d.right;\n      while (successor.left) successor = successor.left;\n      return successor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) {\n        successor = root;\n        root = root.left;\n      } else root = root.right;\n    }\n\n    return successor;\n  }\n\n\n  /**\n   * @param  {Node} d\n   * @return {Node|null}\n   */\n  prev (d) {\n    let root = this._root;\n    let predecessor = null;\n\n    if (d.left !== null) {\n      predecessor = d.left;\n      while (predecessor.right) predecessor = predecessor.right;\n      return predecessor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) root = root.left;\n      else {\n        predecessor = root;\n        root = root.right;\n      }\n    }\n    return predecessor;\n  }\n\n\n  /**\n   * @return {SplayTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n\n  /**\n   * @return {NodeList}\n   */\n  toList() {\n    return toList(this._root);\n  }\n\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param  {Array<Key>}    keys\n   * @param  {Array<Value>}  [values]\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n   *                                         tree's comparator. Sorting is done\n   *                                         in-place\n   * @return {AVLTree}\n   */\n  load (keys = [], values = [], presort = false) {\n    let size = keys.length;\n    const comparator = this._comparator;\n\n    // sort if needed\n    if (presort) sort(keys, values, 0, size - 1, comparator);\n\n    if (this._root === null) { // empty tree\n      this._root = loadRecursive(this._root, keys, values, 0, size);\n      this._size = size;\n    } else { // that re-builds the whole tree from two in-order traversals\n      const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n      size = this._size + size;\n      this._root = sortedListToBST({ head: mergedList }, 0, size);\n    }\n    return this;\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  isEmpty() { return this._root === null; }\n\n  get size () { return this._size; }\n\n\n  /**\n   * @param  {NodePrinter=} printNode\n   * @return {String}\n   */\n  toString (printNode = (n) => n.key) {\n    const out = [];\n    printRow(this._root, '', true, (v) => out.push(v), printNode);\n    return out.join('');\n  }\n\n\n  update (key, newKey, newData) {\n    const comparator = this._comparator;\n    let { left, right } = split(key, this._root, comparator);\n    this._size--;\n    if (comparator(key, newKey) < 0) {\n      right = insert(newKey, newData, right, comparator, this);\n    } else {\n      left = insert(newKey, newData, left, comparator, this);\n    }\n    this._root = merge(left, right, comparator);\n  }\n\n\n  split(key) {\n    return split(key, this._root, this._comparator);\n  }\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction createList(keys, values) {\n  const head = { next: null };\n  let p = head;\n  for (let i = 0; i < keys.length; i++) {\n    p = p.next = { key: keys[i], data: values[i] };\n  }\n  p.next = null;\n  return head.next;\n}\n\n\nfunction toList (root) {\n  var current = root;\n  var Q = [], done = false;\n\n  const head = { next: null };\n  let p = head;\n\n  while (!done) {\n    if (current) {\n      Q.push(current);\n      current = current.left;\n    } else {\n      if (Q.length > 0) {\n        current = p = p.next = Q.pop();\n        current = current.right;\n      } else done = true;\n    }\n  }\n  p.next = null; // that'll work even if the tree was empty\n  return head.next;\n}\n\n\nfunction sortedListToBST(list, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const left = sortedListToBST(list, start, middle);\n\n    const root = list.head;\n    root.left = left;\n\n    list.head = list.head.next;\n\n    root.right = sortedListToBST(list, middle + 1, end);\n    return root;\n  }\n  return null;\n}\n\n\nfunction mergeLists (l1, l2, compare = (a, b) => a - b) {\n  const head = {}; // dummy\n  let p = head;\n\n  let p1 = l1;\n  let p2 = l2;\n\n  while (p1 !== null && p2 !== null) {\n    if (compare(p1.key, p2.key) < 0) {\n      p.next = p1;\n      p1 = p1.next;\n    } else {\n      p.next = p2;\n      p2 = p2.next;\n    }\n    p = p.next;\n  }\n\n  if (p1 !== null)      p.next = p1;\n  else if (p2 !== null) p.next = p2;\n\n  return head.next;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52)\n\nconst EPSILON_SQ = epsilon * epsilon\n\n/* FLP comparator */\nexport const cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0\n    }\n  }\n\n  // check if they're flp equal\n  if ((a - b) * (a - b) < EPSILON_SQ * a * b) {\n    return 0\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1\n}\n\n/* FLP point comparator, favors point encountered first by sweep line */\nexport const cmpPoints = (aPt, bPt) => {\n  if (aPt === bPt) return 0\n\n  // fist compare X, then compare Y\n  let a = aPt.x\n  let b = bPt.x\n\n  // inlined version of cmp() for performance boost\n  if (\n    a <= -epsilon ||\n    epsilon <= a ||\n    b <= -epsilon ||\n    epsilon <= b\n  ) {\n    const diff = a - b\n    if (diff * diff >= EPSILON_SQ * a * b) {\n      return a < b ? -1 : 1\n    }\n  }\n\n  a = aPt.y\n  b = bPt.y\n\n  // inlined version of cmp() for performance boost\n  if (\n    a <= -epsilon ||\n    epsilon <= a ||\n    b <= -epsilon ||\n    epsilon <= b\n  ) {\n    const diff = a - b\n    if (diff * diff >= EPSILON_SQ * a * b) {\n      return a < b ? -1 : 1\n    }\n  }\n\n  // they're the same\n  return 0\n}\n\n/* Greedy comparison. Two numbers are defined to touch\n * if their midpoint is indistinguishable from either. */\nexport const touch = (a, b) => {\n  const m = (a + b) / 2\n  return cmp(m, a) === 0 || cmp(m, b) === 0\n}\n\n/* Greedy comparison. Two points are defined to touch\n * if their midpoint is indistinguishable from either. */\nexport const touchPoints = (aPt, bPt) => {\n  const mPt = { x: (aPt.x + bPt.x) / 2, y: (aPt.y + bPt.y) / 2 }\n  return cmpPoints(mPt, aPt) === 0 || cmpPoints(mPt, bPt) === 0\n}\n","import { cmp } from './flp'\n\n/* Cross Product of two vectors with first point at origin */\nexport const crossProduct = (a, b) => a.x * b.y - a.y * b.x\n\n/* Dot Product of two vectors with first point at origin */\nexport const dotProduct = (a, b) => a.x * b.x + a.y * b.y\n\n/* Comparator for two vectors with same starting point */\nexport const compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const v1 = { x: endPt1.x - basePt.x, y: endPt1.y - basePt.y }\n  const v2 = { x: endPt2.x - basePt.x, y: endPt2.y - basePt.y }\n  const kross = crossProduct(v1, v2)\n  return cmp(kross, 0)\n}\n\nexport const length = v => Math.sqrt(dotProduct(v, v))\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the closest point on an line (defined by two points)\n * to another point. */\nexport const closestPoint = (ptA1, ptA2, ptB) => {\n  if (ptA1.x === ptA2.x) return { x: ptA1.x, y: ptB.y } // vertical vector\n  if (ptA1.y === ptA2.y) return { x: ptB.x, y: ptA1.y } // horizontal vector\n\n  // use the closer point as a base for calcuation\n  const v1 = { x: ptA1.x - ptB.x, y: ptA1.y - ptB.y }\n  const v2 = { x: ptA2.x - ptB.x, y: ptA2.y - ptB.y }\n  let basePt = ptA1\n  let awayPt = ptA2\n  if (dotProduct(v1, v1) > dotProduct(v2, v2)) {\n    awayPt = ptA1\n    basePt = ptA2\n  }\n\n  const vA = { x: awayPt.x - basePt.x, y: awayPt.y - basePt.y }\n  const vB = { x: ptB.x - basePt.x, y: ptB.y - basePt.y }\n  const dist = dotProduct(vA, vB) / dotProduct(vA, vA)\n  return { x: basePt.x + dist * vA.x, y: basePt.y + dist * vA.y }\n}\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null\n  return { x: pt.x + v.x / v.y * ( y - pt.y ), y: y }\n}\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null\n  return { x: x, y: pt.y + v.y / v.x * ( x - pt.x ) }\n}\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const intersection = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x)\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x)\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y)\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y)\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2)\n  if (kross == 0) return null\n\n  const ve = { x: pt2.x - pt1.x, y: pt2.y - pt1.y }\n  const d1 = crossProduct(ve, v1) / kross\n  const d2 = crossProduct(ve, v2) / kross\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x\n  const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y\n  const x = (x1 + x2) / 2\n  const y = (y1 + y2) / 2\n  return { x: x, y: y }\n}\n\n/* Given a vector, return one that is perpendicular */\nexport const perpendicular = (v) => {\n  return { x: -v.y, y: v.x }\n}\n","import { cmpPoints } from './flp'\nimport { compareVectorAngles } from './vector'\n\n/* Given input geometry as a standard array-of-arrays geojson-style\n * geometry, return one that uses objects as points, for better perf */\nexport const pointsAsObjects = geom => {\n  // we can handle well-formed multipolys and polys\n  const output = []\n  if (!Array.isArray(geom)) {\n    throw new Error('Input is not a Polygon or MultiPolygon')\n  }\n  for (let i = 0, iMax = geom.length; i < iMax; i++) {\n    if (!Array.isArray(geom[i]) || geom[i].length == 0) {\n      throw new Error('Input is not a Polygon or MultiPolygon')\n    }\n    output.push([])\n    for (let j = 0, jMax = geom[i].length; j < jMax; j++) {\n      if (!Array.isArray(geom[i][j]) || geom[i][j].length == 0) {\n        throw new Error('Input is not a Polygon or MultiPolygon')\n      }\n      if (Array.isArray(geom[i][j][0])) { // multipolygon\n        output[i].push([])\n        for (let k = 0, kMax = geom[i][j].length; k < kMax; k++) {\n          if (!Array.isArray(geom[i][j][k]) || geom[i][j][k].length < 2) {\n            throw new Error('Input is not a Polygon or MultiPolygon')\n          }\n          if (geom[i][j][k].length > 2) {\n            throw new Error(\n              'Input has more than two coordinates. ' +\n              'Only 2-dimensional polygons supported.'\n            )\n          }\n          output[i][j].push({ x: geom[i][j][k][0], y: geom[i][j][k][1] })\n        }\n      } else { // polygon\n        if (geom[i][j].length < 2) {\n          throw new Error('Input is not a Polygon or MultiPolygon')\n        }\n        if (geom[i][j].length > 2) {\n          throw new Error(\n            'Input has more than two coordinates. ' +\n            'Only 2-dimensional polygons supported.'\n          )\n        }\n        output[i].push({ x: geom[i][j][0], y: geom[i][j][1] })\n      }\n    }\n  }\n  return output\n}\n\n/* WARN: input modified directly */\nexport const forceMultiPoly = geom => {\n  if (Array.isArray(geom)) {\n    if (geom.length === 0) return // allow empty multipolys\n\n    if (Array.isArray(geom[0])) {\n      if (Array.isArray(geom[0][0])) {\n        if (\n          typeof geom[0][0][0].x === 'number' &&\n          typeof geom[0][0][0].y === 'number'\n        ) {\n          // multipolygon\n          return\n        }\n      }\n      if (\n        typeof geom[0][0].x === 'number' &&\n        typeof geom[0][0].y === 'number'\n      ) {\n        // polygon\n        geom.unshift(geom.splice(0))\n        return\n      }\n    }\n  }\n  throw new Error('Unrecognized input - not a polygon nor multipolygon')\n}\n\n/* WARN: input modified directly */\nexport const cleanMultiPoly = multipoly => {\n  let i = 0\n  while (i < multipoly.length) {\n    const poly = multipoly[i]\n    if (poly.length === 0) {\n      multipoly.splice(i, 1)\n      continue\n    }\n\n    const exteriorRing = poly[0]\n    cleanRing(exteriorRing)\n    // poly is dropped if exteriorRing is degenerate\n    if (exteriorRing.length === 0) {\n      multipoly.splice(i, 1)\n      continue\n    }\n\n    let j = 1\n    while (j < poly.length) {\n      const interiorRing = poly[j]\n      cleanRing(interiorRing)\n      if (interiorRing.length === 0) poly.splice(j, 1)\n      else j++\n    }\n\n    i++\n  }\n}\n\n/* Clean ring:\n *  - remove duplicate points\n *  - remove colinear points\n *  - remove rings with no area (less than 3 distinct points)\n *  - un-close rings (last point should not repeat first)\n *\n * WARN: input modified directly */\nexport const cleanRing = ring => {\n  if (ring.length === 0) return\n  if (cmpPoints(ring[0], ring[ring.length - 1]) === 0) ring.pop()\n\n  const isPointUncessary = (prevPt, pt, nextPt) =>\n    cmpPoints(prevPt, pt) === 0 ||\n    cmpPoints(pt, nextPt) === 0 ||\n    compareVectorAngles(pt, prevPt, nextPt) === 0\n\n  let i = 0\n  let prevPt, nextPt\n  while (i < ring.length) {\n    prevPt = (i === 0 ? ring[ring.length - 1] : ring[i - 1])\n    nextPt = (i === ring.length - 1 ? ring[0] : ring[i + 1])\n    if (isPointUncessary(prevPt, ring[i], nextPt)) ring.splice(i, 1)\n    else i++\n  }\n\n  // if our ring has less than 3 distinct points now (so is degenerate)\n  // shrink it down to the empty array to communicate to our caller to\n  // drop it\n  while (ring.length < 3 && ring.length > 0) ring.pop()\n}\n","import { cmp } from './flp'\nimport { cosineOfAngle, sineOfAngle } from './vector'\n\n// Give sweep events unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet sweepEventId = 0\n\nexport default class SweepEvent {\n\n  static compare (a, b) {\n\n    // if the events are already linked, then we know the points are equal\n    if (a.point !== b.point) {\n\n      // favor event with a point that the sweep line hits first\n      const cmpX = cmp(a.point.x, b.point.x)\n      if (cmpX !== 0) return cmpX\n\n      const cmpY = cmp(a.point.y, b.point.y)\n      if (cmpY !== 0) return cmpY\n\n      // Points are equal, so go ahead and link these events.\n      a.link(b)\n    }\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1\n\n    // are they identical?\n    if (a === b) return 0\n\n    // The calcuations of relative segment angle below can give different\n    // results after segment splitting due to rounding errors.\n    // To maintain sweep event queue ordering, we thus skip these calculations\n    // if we already know the segements to be colinear (one of the requirements\n    // of the 'consumedBy' relationship).\n    let aConsumedBy = a\n    let bConsumedBy = b\n    while (aConsumedBy.consumedBy) aConsumedBy = aConsumedBy.consumedBy\n    while (bConsumedBy.consumedBy) bConsumedBy = bConsumedBy.consumedBy\n    if (aConsumedBy !== bConsumedBy) {\n\n      // favor vertical segments for left events, and non-vertical for right\n      // https://github.com/mfogel/polygon-clipping/issues/29\n      const aVert = a.segment.isVertical()\n      const bVert = b.segment.isVertical()\n      if (aVert && ! bVert) return a.isLeft ? 1 : -1\n      if (! aVert && bVert) return a.isLeft ? -1 : 1\n\n      // Favor events where the line segment is lower.\n      // Sometimes, because one segment is longer than the other,\n      // one of these comparisons will return 0 and the other won't.\n      const pointSegCmp = a.segment.compareVertically(b.otherSE.point)\n      if (pointSegCmp === 1) return -1\n      if (pointSegCmp === -1) return 1\n      const otherPointSegCmp = b.segment.compareVertically(a.otherSE.point)\n      if (otherPointSegCmp !== 0) return otherPointSegCmp\n\n      // NOTE:  We don't sort on segment length because that changes\n      //        as segments are divided.\n    }\n\n    // as a tie-breaker, favor lower creation id\n    if (a.id < b.id) return -1\n    if (a.id > b.id) return 1\n\n    throw new Error(\n      `SweepEvent comparison failed at [${a.point.x}, ${a.point.y}]`\n    )\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor (point, isLeft) {\n    if (point.events === undefined) point.events = [this]\n    else point.events.push(this)\n    this.point = point\n    this.isLeft = isLeft\n    this.id = ++sweepEventId\n    // this.segment, this.otherSE set by factory\n  }\n\n  link (other) {\n    if (other.point === this.point) {\n      throw new Error('Tried to link already linked events')\n    }\n    const otherEvents = other.point.events\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i]\n      this.point.events.push(evt)\n      evt.point = this.point\n    }\n    this.segment.checkForConsuming()\n    other.segment.checkForConsuming()\n  }\n\n  getAvailableLinkedEvents () {\n    // point.events is always of length 2 or greater\n    const events = []\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i]\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt)\n      }\n    }\n    return events\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator (baseEvent) {\n    const cache = new Map()\n\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      })\n    }\n\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a)\n      if (!cache.has(b)) fillCache(b)\n\n      const { sine: asine, cosine: acosine } = cache.get(a)\n      const { sine: bsine, cosine: bcosine } = cache.get(b)\n\n      const cmpZeroASine = cmp(asine, 0)\n      const cmpZeroBSine = cmp(bsine, 0)\n\n      if (cmpZeroASine >= 0 && cmpZeroBSine >= 0) return cmp(bcosine, acosine)\n      if (cmpZeroASine < 0 && cmpZeroBSine < 0) return cmp(acosine, bcosine)\n      return cmp(bsine, asine)\n    }\n  }\n}\n","import operation from './operation'\nimport SweepEvent from './sweep-event'\nimport { isInBbox, touchesBbox, getBboxOverlap } from './bbox'\nimport { cmp, cmpPoints, touchPoints } from './flp'\nimport { closestPoint, intersection, verticalIntersection } from './vector'\n\nexport default class Segment {\n  static compare (a, b) {\n\n    const alx = a.leftSE.point.x\n    const aly = a.leftSE.point.y\n    const blx = b.leftSE.point.x\n    const bly = b.leftSE.point.y\n    const arx = a.rightSE.point.x\n    const brx = b.rightSE.point.x\n\n    // check if they're even in the same vertical plane\n    if (cmp(brx, alx) < 0) return 1\n    if (cmp(arx, blx) < 0) return -1\n\n    // check for a consumption relationship. if present,\n    // avoid the segment angle calculations (can yield\n    // inconsistent results after splitting)\n    let aConsumedBy = a\n    let bConsumedBy = b\n    while (aConsumedBy.consumedBy) aConsumedBy = aConsumedBy.consumedBy\n    while (bConsumedBy.consumedBy) bConsumedBy = bConsumedBy.consumedBy\n\n    // for segment angle comparisons\n    let aCmpBLeft, aCmpBRight, bCmpALeft, bCmpARight\n\n    if (aConsumedBy === bConsumedBy) {\n      // are they identical?\n      if (a === b) return 0\n\n      // colinear segments with matching left-endpoints, fall back\n      // on creation order of left sweep events as a tie-breaker\n      const aId = a.leftSE.id\n      const bId = b.leftSE.id\n      if (aId < bId) return -1\n      if (aId > bId) return 1\n\n    } else if (\n      // are a and b colinear?\n      (aCmpBLeft = a.comparePoint(b.leftSE.point)) === 0 &&\n      (aCmpBRight = a.comparePoint(b.rightSE.point)) === 0 &&\n      (bCmpALeft = b.comparePoint(a.leftSE.point)) === 0 &&\n      (bCmpARight = b.comparePoint(a.rightSE.point)) === 0\n    ) {\n      // a & b are colinear\n\n      // colinear segments with non-matching left-endpoints, consider\n      // the more-left endpoint to be earlier\n      const cmpLX = cmp(alx, blx)\n      if (cmpLX !== 0) return cmpLX\n\n      // NOTE: we do not use segment length to break a tie here, because\n      //       when segments are split their length changes\n\n      // colinear segments with matching left-endpoints, fall back\n      // on creation order of left sweep events as a tie-breaker\n      const aId = a.leftSE.id\n      const bId = b.leftSE.id\n      if (aId < bId) return -1\n      if (aId > bId) return 1\n\n    } else {\n      // a & b are not colinear\n\n      const cmpLX = cmp(alx, blx)\n      // if the left endpoints are not in the same vertical line,\n      // consider the placement of the left event of the right-more segment\n      // with respect to the left-more segment.\n      if (cmpLX < 0) {\n        if (aCmpBLeft > 0) return -1\n        if (aCmpBLeft < 0) return 1\n        // NOTE: fall-through is necessary here. why? Can that be avoided?\n      }\n      if (cmpLX > 0) {\n        if (bCmpALeft === undefined) bCmpALeft = b.comparePoint(a.leftSE.point)\n        if (bCmpALeft !== 0) return bCmpALeft\n        // NOTE: fall-through is necessary here. why? Can that be avoided?\n      }\n\n      const cmpLY = cmp(aly, bly)\n      // if left endpoints are in the same vertical line, lower means ealier\n      if (cmpLY !== 0) return cmpLY\n      // left endpoints match exactly\n\n      // special case verticals due to rounding errors\n      // part of https://github.com/mfogel/polygon-clipping/issues/29\n      const aVert = a.isVertical()\n      if (aVert !== b.isVertical()) return aVert ? 1 : -1\n\n      // sometimes, because one segment is longer than the other,\n      // one of these comparisons will return 0 and the other won't\n      if (aCmpBRight === undefined) aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight > 0) return -1\n      if (aCmpBRight < 0) return 1\n      if (bCmpARight === undefined) bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n    }\n\n    throw new Error(\n      'Segment comparison of ' +\n      `[${a.leftSE.point.x}, ${a.leftSE.point.y}] -> [${a.rightSE.point.x}, ${a.rightSE.point.y}] ` +\n      'against ' +\n      `[${b.leftSE.point.x}, ${b.leftSE.point.y}] -> [${b.rightSE.point.x}, ${b.rightSE.point.y}] ` +\n      'failed. Please submit a bug report.'\n    )\n  }\n\n  /* Warning: a reference to ringsIn input will be stored,\n   *  and possibly will be later modified */\n  constructor (leftSE, rightSE, ringsIn) {\n    this.leftSE = leftSE\n    leftSE.segment = this\n    leftSE.otherSE = rightSE\n    this.rightSE = rightSE\n    rightSE.segment = this\n    rightSE.otherSE = leftSE\n    this.ringsIn = ringsIn\n    this._cache = {}\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  static fromRing(point1, point2, ring) {\n    let leftSE, rightSE\n    const ptCmp = cmpPoints(point1, point2)\n    if (ptCmp < 0) {\n      leftSE = new SweepEvent(point1, true)\n      rightSE = new SweepEvent(point2, false)\n    } else if (ptCmp > 0) {\n      leftSE = new SweepEvent(point2, true)\n      rightSE = new SweepEvent(point1, false)\n    } else {\n      throw new Error(\n        `Tried to create degenerate segment at [${point1.x}, ${point2.y}]`\n      )\n    }\n    return new Segment(leftSE, rightSE, [ring])\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE (newRightSE) {\n    this.rightSE = newRightSE\n    this.rightSE.segment = this\n    this.rightSE.otherSE = this.leftSE\n    this.leftSE.otherSE = this.rightSE\n  }\n\n  bbox () {\n    const y1 = this.leftSE.point.y\n    const y2 = this.rightSE.point.y\n    return {\n      ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 }\n    }\n  }\n\n  /* A vector from the left point to the right */\n  vector () {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    }\n  }\n\n  isVertical () {\n    return cmp(this.leftSE.point.x, this.rightSE.point.x) === 0\n  }\n\n  isAnEndpoint (point) {\n    return (\n      cmpPoints(point, this.leftSE.point) === 0 ||\n      cmpPoints(point, this.rightSE.point) === 0\n    )\n  }\n\n  /* Compare this segment with a point. Return value indicates:\n   *     1: point lies above or to the left of segment\n   *     0: point is colinear to segment\n   *    -1: point is below or to the right of segment */\n  comparePoint (point) {\n    if (this.isAnEndpoint(point)) return 0\n    const interPt = closestPoint(this.leftSE.point, this.rightSE.point, point)\n\n    const cmpY = cmp(point.y, interPt.y)\n    if (cmpY !== 0) return cmpY\n\n    const cmpX = cmp(point.x, interPt.x)\n    const segCmpX = cmp(this.leftSE.point.y, this.rightSE.point.y)\n\n    // depending on if our segment angles up or down,\n    // the x coord comparison means oppposite things\n    if (cmpX > 0) return segCmpX\n    if (cmpX < 0) {\n      if (segCmpX > 0) return -1\n      if (segCmpX < 0) return 1\n    }\n    return 0\n  }\n\n  /* Compare point vertically with segment.\n   *    1: point is below segment\n   *    0: segment appears to be vertical\n   *   -1: point is above segment */\n  compareVertically (point) {\n    if (this.isAnEndpoint(point)) return 0\n    const interPt = verticalIntersection(this.leftSE.point, this.vector(), point.x)\n\n    // Trying to be as exact as possible here, hence not using flp comparisons\n    if (interPt !== null) {\n      if (point.y < interPt.y) return -1\n      if (point.y > interPt.y) return 1\n    }\n    return 0\n  }\n\n  /* Does the point in question touch the given segment?\n   * Greedy - essentially a 2 * Number.EPSILON comparison.\n   * If it's not possible to add an independent point between the\n   * point and the segment, we say the point 'touches' the segment. */\n  touches (point) {\n    if (!touchesBbox(this.bbox(), point)) return false\n    // if the points have been linked already, performance boost use that\n    if (point === this.leftSE.point || point === this.rightSE.point) return true\n    const cPt1 = closestPoint(this.leftSE.point, this.rightSE.point, point)\n    const avgPt1 = { x: (cPt1.x + point.x) / 2, y: (cPt1.y + point.y) / 2 }\n    return touchPoints(avgPt1, cPt1) || touchPoints(avgPt1, point)\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection (other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const bboxOverlap = getBboxOverlap(this.bbox(), other.bbox())\n    if (bboxOverlap === null) return null\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    // does each endpoint touch the other segment?\n    const touchesOtherLSE = this.touches(other.leftSE.point)\n    const touchesThisLSE = other.touches(this.leftSE.point)\n    const touchesOtherRSE = this.touches(other.rightSE.point)\n    const touchesThisRSE = other.touches(this.rightSE.point)\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return this.rightSE.point\n      if (!touchesThisRSE && touchesOtherRSE) return other.rightSE.point\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE && cmpPoints(this.leftSE.point, other.rightSE.point) === 0) return null\n      // t-intersection on left endpoint\n      return this.leftSE.point\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE && cmpPoints(this.rightSE.point, other.leftSE.point) === 0) return null\n      // t-intersection on left endpoint\n      return other.leftSE.point\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return this.rightSE.point\n    if (touchesOtherRSE) return other.rightSE.point\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection(this.leftSE.point, this.vector(), other.leftSE.point, other.vector())\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null\n\n    // We don't need to check if we need to 'snap' to an endpoint,\n    // because the endpoint cmps we did eariler were greedy\n    return pt\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split (points) {\n    // sort the points in sweep line order\n    points.sort(cmpPoints)\n\n    let prevSeg = this\n    let prevPoint = null\n\n    const newEvents = []\n    for (let i = 0, iMax = points.length; i < iMax; i++) {\n      const point = points[i]\n      // skip repeated points\n      if (prevPoint && cmpPoints(prevPoint, point) === 0) continue\n      const alreadyLinked = point.events !== undefined\n\n      const newLeftSE = new SweepEvent(point, true)\n      const newRightSE = new SweepEvent(point, false)\n      const oldRightSE = prevSeg.rightSE\n      prevSeg.replaceRightSE(newRightSE)\n      newEvents.push(newRightSE)\n      newEvents.push(newLeftSE)\n\n      prevSeg = new Segment(newLeftSE, oldRightSE, prevSeg.ringsIn.slice())\n\n      // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n      if (alreadyLinked) {\n        newLeftSE.segment.checkForConsuming()\n        newRightSE.segment.checkForConsuming()\n      }\n\n      prevPoint = point\n    }\n\n    return newEvents\n  }\n\n  /* Do a pass over the linked events and to see if any segments\n   * should be consumed. If so, do it. */\n  checkForConsuming () {\n    if (this.leftSE.point.events.length === 1) return\n    if (this.rightSE.point.events.length === 1) return\n    for (let i = 0, iMax = this.leftSE.point.events.length; i < iMax; i++) {\n      const le = this.leftSE.point.events[i]\n      if (le === this.leftSE) continue\n      for (let j = 0, jMax = this.rightSE.point.events.length; j < jMax; j++) {\n        const re = this.rightSE.point.events[j]\n        if (re === this.rightSE) continue\n        if (le.segment === re.segment) this.consume(le.segment)\n      }\n    }\n  }\n\n  /* Consume another segment. We take their ringsIn under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume (other) {\n    let consumer = this\n    let consumee = other\n    while (consumer.consumedBy) consumer = consumer.consumedBy\n    while (consumee.consumedBy) consumee = consumee.consumedBy\n\n    const cmp = Segment.compare(consumer, consumee)\n    if (cmp === 0) return  // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp  > 0) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    for (let i = 0, iMax = consumee.ringsIn.length; i < iMax; i++) {\n      consumer.ringsIn.push(consumee.ringsIn[i])\n    }\n    consumee.ringsIn = null\n    consumee.consumedBy = consumer\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE\n    consumee.rightSE.consumedBy = consumer.rightSE\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult () {\n    const key = 'prevInResult'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _prevInResult () {\n    if (! this.prev) return null\n    if (this.prev.isInResult()) return this.prev\n    return this.prev.prevInResult()\n  }\n\n  ringsBefore () {\n    const key = 'ringsBefore'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _ringsBefore () {\n    if (! this.prev) return []\n    return (this.prev.consumedBy || this.prev).ringsAfter()\n  }\n\n  ringsAfter () {\n    const key = 'ringsAfter'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _ringsAfter () {\n    const rings = this.ringsBefore().slice(0)\n    for (let i = 0, iMax = this.ringsIn.length; i < iMax; i++) {\n      const ring = this.ringsIn[i]\n      const index = rings.indexOf(ring)\n      if (index === -1) rings.push(ring)\n      else rings.splice(index, 1)\n    }\n    return rings\n  }\n\n  multiPolysBefore () {\n    const key = 'multiPolysBefore'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _multiPolysBefore () {\n    if (! this.prev) return []\n    return (this.prev.consumedBy || this.prev).multiPolysAfter()\n  }\n\n  multiPolysAfter () {\n    const key = 'multiPolysAfter'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _multiPolysAfter () {\n    // first calcualte our polysAfter\n    const polysAfter = []\n    const polysExclude = []\n    const ringsAfter = this.ringsAfter()\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      const ring = ringsAfter[i]\n      const poly = ring.poly\n      if (polysExclude.indexOf(poly) !== -1) continue\n      if (ring.isExterior) polysAfter.push(poly)\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly)\n        const index = polysAfter.indexOf(ring.poly)\n        if (index !== -1) polysAfter.splice(index, 1)\n      }\n    }\n    // now calculate our multiPolysAfter\n    const mps = []\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly\n      if (mps.indexOf(mp) === -1) mps.push(mp)\n    }\n    return mps\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult () {\n    const key = 'isInResult'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _isInResult () {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false\n\n    const mpsBefore = this.multiPolysBefore()\n    const mpsAfter = this.multiPolysAfter()\n\n    switch (operation.type) {\n      case 'union': {\n        // UNION - included iff:\n        //  * On one side of us there is 0 poly interiors AND\n        //  * On the other side there is 1 or more.\n        const noBefores = mpsBefore.length === 0\n        const noAfters = mpsAfter.length === 0\n        return noBefores !== noAfters\n      }\n\n      case 'intersection': {\n        // INTERSECTION - included iff:\n        //  * on one side of us all multipolys are rep. with poly interiors AND\n        //  * on the other side of us, not all multipolys are repsented\n        //    with poly interiors\n        let least\n        let most\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length\n          most = mpsAfter.length\n        } else {\n          least = mpsAfter.length\n          most = mpsBefore.length\n        }\n        return most === operation.numMultiPolys && least < most\n      }\n\n      case 'xor': {\n        // XOR - included iff:\n        //  * the difference between the number of multipolys represented\n        //    with poly interiors on our two sides is an odd number\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length)\n        return diff % 2 === 1\n      }\n\n      case 'difference': {\n        // DIFFERENCE included iff:\n        //  * on exactly one side, we have just the subject\n        const isJustSubject = mps => mps.length === 1 && mps[0].isSubject\n        return isJustSubject(mpsBefore) !== isJustSubject(mpsAfter)\n      }\n\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`)\n    }\n  }\n\n}\n","import { cmp, touch } from './flp'\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nexport const isInBbox = (bbox, point) => {\n  return (\n    cmp(bbox.ll.x, point.x) <= 0 &&\n    cmp(point.x, bbox.ur.x) <= 0 &&\n    cmp(bbox.ll.y, point.y) <= 0 &&\n    cmp(point.y, bbox.ur.y) <= 0\n  )\n}\n\n/* Greedy comparison with a bbox. A point is defined to 'touch'\n * a bbox if:\n *  - it is inside the bbox\n *  - it 'touches' one of the sides (another greedy comparison) */\nexport const touchesBbox = (bbox, point) => {\n  return (\n    (cmp(bbox.ll.x, point.x) <= 0 || touch(bbox.ll.x, point.x)) &&\n    (cmp(point.x, bbox.ur.x) <= 0 || touch(point.x, bbox.ur.x)) &&\n    (cmp(bbox.ll.y, point.y) <= 0 || touch(bbox.ll.y, point.y)) &&\n    (cmp(point.y, bbox.ur.y) <= 0 || touch(point.y, bbox.ur.y))\n  )\n}\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nexport const getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (\n    cmp(b2.ur.x, b1.ll.x) < 0 ||\n    cmp(b1.ur.x, b2.ll.x) < 0 ||\n    cmp(b2.ur.y, b1.ll.y) < 0 ||\n    cmp(b1.ur.y, b2.ll.y) < 0\n  ) return null\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y\n\n  // put those middle values together to get the overlap\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } }\n}\n","import Segment from './segment'\n\nexport class RingIn {\n  constructor (geomRing, poly, isExterior) {\n    this.poly = poly\n    this.isExterior = isExterior\n    this.segments = []\n\n    let prevPoint = geomRing[0]\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      let point = geomRing[i]\n      this.segments.push(Segment.fromRing(prevPoint, point, this))\n      prevPoint = point\n    }\n    this.segments.push(Segment.fromRing(prevPoint, geomRing[0], this))\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i]\n      sweepEvents.push(segment.leftSE)\n      sweepEvents.push(segment.rightSE)\n    }\n    return sweepEvents\n  }\n}\n\nexport class PolyIn {\n  constructor (geomPoly, multiPoly) {\n    this.exteriorRing = new RingIn(geomPoly[0], this, true)\n    this.interiorRings = []\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      this.interiorRings.push(new RingIn(geomPoly[i], this, false))\n    }\n    this.multiPoly = multiPoly\n  }\n\n  getSweepEvents () {\n    const sweepEvents = this.exteriorRing.getSweepEvents()\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents()\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n\nexport class MultiPolyIn {\n  constructor (geomMultiPoly) {\n    this.polys = []\n    for (let i = 0, iMax = geomMultiPoly.length; i < iMax; i++) {\n      this.polys.push(new PolyIn(geomMultiPoly[i], this))\n    }\n    this.isSubject = false\n  }\n\n  markAsSubject () {\n    this.isSubject = true\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents()\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n","import { compareVectorAngles } from './vector'\nimport SweepEvent from './sweep-event'\n\nexport class RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory (allSegments) {\n    const ringsOut = []\n\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i]\n      if (!segment.isInResult() || segment.ringOut) continue\n\n      let prevEvent = null\n      let event = segment.leftSE\n      let nextEvent = segment.rightSE\n      const events = [event]\n\n      const startingPoint = event.point\n      const intersectionLEs = []\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event\n        event = nextEvent\n        events.push(event)\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break\n\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents()\n\n          /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n           * part of the algorithm malfunctioned... please file a bug report. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point\n            const lastPt = events[events.length - 1].point\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x},` +\n                ` ${firstPt.y}]. Last matching segment found ends at` +\n                ` [${lastPt.x}, ${lastPt.y}].`\n            )\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE\n            break\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j\n              break\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0]\n            const ringEvents = events.splice(intersectionLE.index)\n            ringEvents.unshift(ringEvents[0].otherSE)\n            ringsOut.push(new RingOut(ringEvents.reverse()))\n            continue\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point,\n          })\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent)\n          nextEvent = availableLEs.sort(comparator)[0].otherSE\n          break\n        }\n      }\n\n      ringsOut.push(new RingOut(events))\n    }\n    return ringsOut\n  }\n\n  constructor (events) {\n    this.events = events\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this\n    }\n    this.poly = null\n  }\n\n  getGeom () {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point\n    const points = [prevPt]\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point\n      const nextPt = this.events[i + 1].point\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue\n      points.push(pt)\n      prevPt = pt\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null\n\n    // check if the starting point is necessary\n    const pt = points[0]\n    const nextPt = points[1]\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift()\n\n    points.push(points[0])\n    const step = this.isExteriorRing() ? 1 : -1\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1\n    const iEnd = this.isExteriorRing() ? points.length : -1\n    const orderedPoints = []\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y])\n    return orderedPoints\n  }\n\n  isExteriorRing () {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing()\n      this._isExteriorRing = enclosing ? ! enclosing.isExteriorRing() : true\n    }\n    return this._isExteriorRing\n  }\n\n  enclosingRing () {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing()\n    }\n    return this._enclosingRing\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing () {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0]\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i]\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt\n    }\n\n    let prevSeg = leftMostEvt.segment.prevInResult()\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut\n        } else return prevSeg.ringOut.enclosingRing()\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult()\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n    }\n  }\n}\n\nexport class PolyOut {\n  constructor (exteriorRing) {\n    this.exteriorRing = exteriorRing\n    exteriorRing.poly = this\n    this.interiorRings = []\n  }\n\n  addInterior (ring) {\n    this.interiorRings.push(ring)\n    ring.poly = this\n  }\n\n  getGeom () {\n    const geom = [this.exteriorRing.getGeom()]\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom()\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue\n      geom.push(ringGeom)\n    }\n    return geom\n  }\n}\n\nexport class MultiPolyOut {\n  constructor (rings) {\n    this.rings = rings\n    this.polys = this._composePolys(rings)\n  }\n\n  getGeom () {\n    const geom = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom()\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue\n      geom.push(polyGeom)\n    }\n    return geom\n  }\n\n  _composePolys (rings) {\n    const polys = []\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i]\n      if (ring.poly) continue\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring))\n      else {\n        const enclosingRing = ring.enclosingRing()\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing))\n        enclosingRing.poly.addInterior(ring)\n      }\n    }\n    return polys\n  }\n}\n","import SplayTree from 'splaytree'\nimport Segment from './segment'\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nexport default class SweepLine {\n  constructor (queue, comparator = Segment.compare) {\n    this.queue = queue\n    this.tree = new SplayTree(comparator)\n    this.segments = []\n  }\n\n  process (event) {\n    const segment = event.segment\n    const newEvents = []\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE)\n      else this.tree.remove(segment)\n      return newEvents\n    }\n\n    const node = event.isLeft\n      ? this.tree.insert(segment)\n      : this.tree.find(segment)\n\n    if (! node) throw new Error(\n      'Unable to find segment ' +\n      `#${segment.leftSE.id} [${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` +\n      `#${segment.rightSE.id} [${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` +\n      'in SweepLine tree. Please submit a bug report.'\n    )\n\n    let prevNode = node\n    let nextNode = node\n    let prevSeg = undefined\n    let nextSeg = undefined\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode)\n      if (prevNode === null) prevSeg = null\n      else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode)\n      if (nextNode === null) nextSeg = null\n      else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key\n    }\n\n    if (event.isLeft) {\n      // TODO: would it make sense to just stop and bail out at the first time we're split?\n      //       rather than split ourselves multiple times?\n      const mySplitters = []\n\n      // Check for intersections against the previous segment in the sweep line\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment)\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) mySplitters.push(prevInter)\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment)\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) mySplitters.push(nextInter)\n          if (!nextSeg.isAnEndpoint(nextInter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // split ourselves if need be\n      if (mySplitters.length > 0) {\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE)\n        newEvents.push(segment.rightSE)\n\n        const newEventsFromSplit = segment.split(mySplitters)\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i])\n        }\n      }\n\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment)\n        newEvents.push(event)\n\n      } else {\n        // done with left event\n        this.segments.push(segment)\n        segment.prev = prevSeg\n      }\n\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg)\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      this.tree.remove(segment)\n    }\n\n    return newEvents\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg)\n    const rightSE = seg.rightSE\n    this.queue.remove(rightSE)\n    const newEvents = seg.split([pt])\n    newEvents.push(rightSE)\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.insert(seg)\n    return newEvents\n  }\n}\n","import SplayTree from 'splaytree'\nimport * as cleanInput from './clean-input'\nimport * as geomIn from './geom-in'\nimport * as geomOut from './geom-out'\nimport SweepEvent from './sweep-event'\nimport SweepLine from './sweep-line'\n\nexport class Operation {\n  run (type, geom, moreGeoms) {\n    operation.type = type\n\n    /* Make a copy of the input geometry with points as objects, for perf */\n    const geoms = [cleanInput.pointsAsObjects(geom)]\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      geoms.push(cleanInput.pointsAsObjects(moreGeoms[i]))\n    }\n\n    /* Clean inputs */\n    for (let i = 0, iMax = geoms.length; i < iMax; i++) {\n      cleanInput.forceMultiPoly(geoms[i])\n      cleanInput.cleanMultiPoly(geoms[i])\n    }\n\n    /* Convert inputs to MultiPoly objects, mark subject */\n    const multipolys = []\n    for (let i = 0, iMax = geoms.length; i < iMax; i++) {\n      multipolys.push(new geomIn.MultiPolyIn(geoms[i]))\n    }\n    multipolys[0].markAsSubject()\n    operation.numMultiPolys = multipolys.length\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare)\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents()\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j])\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue)\n    let prevQueueSize = queue.size\n    let node = queue.pop()\n    while (node) {\n      const evt = node.key\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\n          `Unable to pop() SweepEvent #${evt.id} [${evt.point.x}, ${evt.point.y}] ` +\n          'from queue. Please file a bug report.'\n        )\n      }\n      const newEvents = sweepLine.process(evt)\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i]\n        if (evt.consumedBy === undefined) queue.insert(evt)\n      }\n      prevQueueSize = queue.size\n      node = queue.pop()\n    }\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = geomOut.RingOut.factory(sweepLine.segments)\n    const result = new geomOut.MultiPolyOut(ringsOut)\n    return result.getGeom()\n  }\n}\n\n// singleton available by import\nconst operation = new Operation()\n\nexport default operation\n","import operation from './operation'\n\nconst union = (geom, ...moreGeoms) =>\n  operation.run('union', geom, moreGeoms)\n\nconst intersection = (geom, ...moreGeoms) =>\n  operation.run('intersection', geom, moreGeoms)\n\nconst xor = (geom, ...moreGeoms) =>\n  operation.run('xor', geom, moreGeoms)\n\nconst difference = (subjectGeom, ...clippingGeoms) =>\n  operation.run('difference', subjectGeom, clippingGeoms)\n\nexport default {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference,\n}\n"],"names":["Node","key","data","left","right","DEFAULT_COMPARE","a","b","splay","i","t","comparator","l","r","y","N","cmp","insert","tree","node","_size","remove","x","split","v","Tree","_comparator","_root","this","add","current","compare","visitor","ctx","Q","done","push","length","pop","call","low","high","fn","keys","forEach","values","minNode","maxNode","index","d","root","successor","predecessor","head","next","p","toList","presort","size","sort","pivot","j","tmp","loadRecursive","parent","start","end","middle","Math","floor","mergedList","l1","l2","p1","p2","mergeLists","createList","sortedListToBST","list","printNode","n","out","printRow","prefix","isTail","indent","join","newKey","newData","merge","epsilon","Number","EPSILON","undefined","pow","EPSILON_SQ","cmpPoints","aPt","bPt","diff","touch","m","touchPoints","mPt","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","cosineOfAngle","pShared","pBase","pAngle","vBase","vAngle","closestPoint","ptA1","ptA2","ptB","awayPt","vA","vB","dist","horizontalIntersection","pt","verticalIntersection","pointsAsObjects","geom","output","Array","isArray","Error","iMax","jMax","k","kMax","forceMultiPoly","unshift","splice","cleanMultiPoly","multipoly","poly","exteriorRing","cleanRing","interiorRing","ring","prevPt","nextPt","isPointUncessary","sweepEventId","SweepEvent","point","isLeft","events","id","cmpX","cmpY","link","aConsumedBy","bConsumedBy","consumedBy","aVert","segment","isVertical","bVert","pointSegCmp","compareVertically","otherSE","otherPointSegCmp","other","otherEvents","evt","checkForConsuming","ringOut","isInResult","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","_this","cosine","has","get","asine","acosine","bsine","bcosine","cmpZeroASine","cmpZeroBSine","Segment","leftSE","rightSE","ringsIn","_cache","alx","aly","blx","bly","arx","brx","aCmpBLeft","aCmpBRight","bCmpALeft","bCmpARight","aId","bId","comparePoint","cmpLX","cmpLY","newRightSE","y1","y2","ll","ur","isAnEndpoint","interPt","segCmpX","vector","bbox","touchesBbox","cPt1","avgPt1","bboxOverlap","b1","b2","lowerX","upperX","getBboxOverlap","touchesOtherLSE","touches","touchesThisLSE","touchesOtherRSE","touchesThisRSE","pt1","pt2","ve","d1","d2","intersection","points","prevSeg","prevPoint","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","slice","le","re","consume","consumer","consumee","prev","prevInResult","ringsAfter","rings","ringsBefore","indexOf","multiPolysAfter","polysAfter","polysExclude","isExterior","mps","mp","multiPoly","mpsBefore","multiPolysBefore","mpsAfter","operation","type","least","most","numMultiPolys","abs","isJustSubject","isSubject","point1","point2","ptCmp","RingIn","geomRing","segments","fromRing","sweepEvents","PolyIn","geomPoly","interiorRings","getSweepEvents","ringSweepEvents","MultiPolyIn","geomMultiPoly","polys","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","firstPt","lastPt","indexLE","getLeftmostComparator","intersectionLE","ringEvents","reverse","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevPrevSeg","PolyOut","getGeom","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","SplayTree","find","prevNode","nextNode","nextSeg","mySplitters","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextInter","inter","seg","moreGeoms","geoms","cleanInput","multipolys","geomIn","markAsSubject","sweepLine","prevQueueSize","process","geomOut","factory","union","run","xor","difference","subjectGeom","clippingGeoms"],"mappings":"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"}